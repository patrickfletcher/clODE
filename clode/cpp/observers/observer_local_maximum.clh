//Event is the detection of local max in specified variable fVarIx

#ifndef OBSERVER_LOCAL_MAX_H
#define OBSERVER_LOCAL_MAX_H


#ifdef __cplusplus
//Collect all the info for this observer. Must be a static function when defining function in header, otherwise defined for each time included.
static ObserverInfo getObserverInfo_localmax(const ProblemInfo pi, const unsigned int fVarIx, const unsigned int eVarIx, const unsigned int nPhase)
{
    ObserverInfo oi;
    oi.define="USE_OBSERVER_LOCAL_MAX";
    size_t n_real=(3*pi.nVar*2 + pi.nVar*6 + pi.nAux*3 + 3*4 + 5 ); //hard coded, because C++ code can't see the N_VAR, N_AUX etc...
    size_t n_int=5;
    oi.observerDataSizeFloat=n_real*sizeof(cl_float) + n_int*sizeof(cl_uint);
    oi.observerDataSizeDouble=n_real*sizeof(cl_double) + n_int*sizeof(cl_uint); 
    
    std::string varName=pi.varNames[fVarIx];
    oi.featureNames={
        "max IMI",
        "min IMI",
        "mean IMI",
        "max amplitude",
        "min amplitude",
        "mean amplitude",
        "max " + varName,
        "min " + varName,
        "mean " + varName,
        "max d" + varName + "/dt",
        "min d" + varName + "/dt",
        "event count",
        "step count",
    };
    return oi;
}
#endif


#ifdef USE_OBSERVER_LOCAL_MAX
//events are triggered at local maxima in the variable specified by op.fVarIx

typedef struct ObserverData_localmax
{
    realtype tbuffer[3];
    realtype xbuffer[3 * N_VAR];
    realtype dxbuffer[3 * N_VAR];

    realtype xTrajectoryMax[N_VAR];
    realtype xTrajectoryMin[N_VAR];
    realtype xTrajectoryMean[N_VAR];
    realtype dxTrajectoryMax[N_VAR];
    realtype dxTrajectoryMin[N_VAR];

    realtype auxTrajectoryMax[N_AUX];
    realtype auxTrajectoryMin[N_AUX];
    realtype auxTrajectoryMean[N_AUX];

    realtype IMI[3]; //max/min/mean
    realtype amp[3]; //max/min/mean
    // realtype tMaxMin[3]; //max/min/mean
    // realtype xMax[3]; //max/min/mean
    // realtype xMin[3]; //max/min/mean

    realtype xTrajectoryMean;
    realtype xGlobalMax;
    realtype xGlobalMin;
    realtype dxGlobalMax;
    realtype dxGlobalMin;

    realtype t_start;
    realtype tLastMax;
    realtype tLastMin;
    realtype xLastMin;

    unsigned int eventcount;
    unsigned int stepcount;

} ObserverData;

//set initial values to relevant fields in ObserverData
inline void initializeObserverData(realtype *ti, realtype xi[], realtype dxi[], realtype auxi[], ObserverData *od, __constant struct ObserverParams *op)
{

    od->tbuffer[2] = *ti;
    od->xbuffer[2] = xi[op->fVarIx];
    od->dxbuffer[2] = dxi[op->fVarIx];

    od->IMI[0] = -BIG_REAL;
    od->IMI[1] = BIG_REAL;
    od->IMI[2] = RCONST(0.0);

    od->amp[0] = -BIG_REAL;
    od->amp[1] = BIG_REAL;
    od->amp[2] = RCONST(0.0);

    //od->tMaxMin[0]=-BIG_REAL;
    //od->tMaxMin[1]= BIG_REAL;
    //od->tMaxMin[2]= RCONST(0.0);

    // od->xMax[0] = -BIG_REAL;
    // od->xMax[1] = BIG_REAL;
    // od->xMax[2] = RCONST(0.0);

    // od->xMin[0] = -BIG_REAL;
    // od->xMin[1] = BIG_REAL;
    // od->xMin[2] = RCONST(0.0);

    od->xTrajectoryMean = RCONST(0.0);
    od->xGlobalMax = -BIG_REAL;
    od->xGlobalMin = BIG_REAL;
    od->dxGlobalMax = -BIG_REAL;
    od->dxGlobalMin = BIG_REAL;

    od->t_start = *ti;
    od->tLastMax = RCONST(0.0);
    od->tLastMin = RCONST(0.0);
    od->xLastMin = BIG_REAL;

    od->eventcount = 0;
    od->stepcount = 0;
}

//no warmup needed
inline void warmupObserverData(realtype *ti, realtype xi[], realtype dxi[], realtype auxi[], ObserverData *od, __constant struct ObserverParams *op)
{
}

//process warmup data to compute relevant event detector quantities (e.g. thresholds)
inline void initializeEventDetector(realtype *ti, realtype xi[], realtype dxi[], realtype auxi[], ObserverData *od, __constant struct ObserverParams *op)
{
}

//check buffer of slopes for local max
inline bool eventFunction(realtype *ti, realtype xi[], realtype dxi[], realtype auxi[], ObserverData *od, __constant struct ObserverParams *op)
{
    if (od->stepcount < 2)
        return false;

    // Event is a local maximum
    return (od->dxbuffer[1] >= 0.0 && od->dxbuffer[2] < 0.0);
}

//When an event is detected, computes desired event-based features. returns true if a terminal event was reached
// - get (t,x) at local max, compute: IMI, tMaxMin, amp
inline bool computeEventFeatures(realtype *ti, realtype xi[], realtype dxi[], realtype auxi[], ObserverData *od, __constant struct ObserverParams *op)
{
    ++od->eventcount;

    //Simple Max of xbuffer
    realtype thisXbuffer[3];
    for (int j = 0; j < 3; ++j)
     	thisXbuffer[j] = od->xbuffer[j];

    int ix;
    realtype xThisMax;
    maxOfArray(thisXbuffer, 3, &xThisMax, &ix);
    realtype tThisMax = od->tbuffer[ix];

    //Quadratic interpolation for improved accuracy BROKEN??
    //quadraticInterpVertex(od->tbuffer, od->xbuffer, &tThisMax, &xThisMax);

    if (od->eventcount > 1)
    { //implies tLastMax, tLastMin and xLastMin are set
    
        // od->xMax[0] = fmax(xThisMax, od->xMax[0]);
        // od->xMax[1] = fmin(xThisMax, od->xMax[1]);
        // runningMean(&od->xMax[2], xThisMax, od->eventcount - 1);

        // od->xMin[0] = fmax(od->xLastMin, od->xMin[0]); //must have had two maxima to have found one minimum
        // od->xMin[1] = fmin(od->xLastMin, od->xMin[1]);
        // runningMean(&od->xMin[2], od->xLastMin, od->eventcount - 1);

        //max/min/mean IMI
        realtype thisIMI = tThisMax - od->tLastMax;
        //if(thisIMI > op->minIMI) {
        od->IMI[0] = fmax(thisIMI, od->IMI[0]);
        od->IMI[1] = fmin(thisIMI, od->IMI[1]);
        runningMean(&od->IMI[2], thisIMI, od->eventcount - 1);
        //}

        //max/min/mean tMaxMin
        //realtype thisTMaxMin=tThisMax-od->tLastMin;
        //od->tMaxMin[0]=fmax(thisTMaxMin, od->tMaxMin[0]);
        //od->tMaxMin[1]=fmin(thisTMaxMin, od->tMaxMin[1]);
        //runningMean(&od->tMaxMin[2],thisTMaxMin,od->eventcount-1);

        //max/min/mean amp
        realtype thisAmp = xThisMax - od->xLastMin;
        od->amp[0] = fmax(thisAmp, od->amp[0]);
        od->amp[1] = fmin(thisAmp, od->amp[1]);
        runningMean(&od->amp[2], thisAmp, od->eventcount - 1);
    }

    //update stored "last" values
    od->tLastMax = tThisMax;
    od->xLastMin = xi[op->fVarIx];

    if (od->eventcount >= op->maxEventCount){
        return true;
    }
    return false; //not terminal
}

//full per-timestep update of observer data. If an event occurred this timestep, event-based observer data is reset. Per-timestep features are computed here.
// - advance solution/slope buffers
// - check for any intermediate special points & store their info
// - reset intermediates upon local max event detection
inline void updateObserverData(realtype *ti, realtype xi[], realtype dxi[], realtype auxi[], ObserverData *od, __constant struct ObserverParams *op)
{
    ++od->stepcount;

    // advance solution buffer
    od->tbuffer[0] = od->tbuffer[1];
    od->tbuffer[1] = od->tbuffer[2];
    od->tbuffer[2] = *ti;

    for (int j = 0; j < N_VAR; ++j)
    {
        od->xbuffer[j * 3 + 0] = od->xbuffer[j * 3 + 1];
        od->xbuffer[j * 3 + 1] = od->xbuffer[j * 3 + 2];
        od->xbuffer[j * 3 + 2] = xi[j];
        od->dxbuffer[j * 3 + 0] = od->dxbuffer[j * 3 + 1];
        od->dxbuffer[j * 3 + 1] = od->dxbuffer[j * 3 + 2];
        od->dxbuffer[j * 3 + 2] = dxi[j];
    }

    // dt is available in the calling ode-driver. 
    realtype dt = od->tbuffer[2]-od->tbuffer[1];
    realtype elapsedTime = *ti - od->t_start;

    od->stepDt[0] = fmax(dt, od->stepDt[0]);
    od->stepDt[1] = fmin(dt, od->stepDt[1]);
    runningMean(&od->stepDt[2], dt, od->stepcount);

    //global extent of all vars, var slopes, and aux vars
    for (int j = 0; j < N_VAR; ++j)
    {
        od->xTrajectoryMax[j] = fmax(xi[j], od->xTrajectoryMax[j]);
        od->xTrajectoryMin[j] = fmin(xi[j], od->xTrajectoryMin[j]);
        od->xTrajectoryMean[j] = runningMeanTime(od->xTrajectoryMean[j], xi[j], dt, elapsedTime);
        od->dxTrajectoryMax[j] = fmax(dxi[j], od->dxTrajectoryMax[j]);
        od->dxTrajectoryMin[j] = fmin(dxi[j], od->dxTrajectoryMin[j]);
    }
    for (int j = 0; j < N_AUX; ++j)
    {
        od->auxTrajectoryMax[j] = fmax(auxi[j], od->auxTrajectoryMax[j]);
        od->auxTrajectoryMin[j] = fmin(auxi[j], od->auxTrajectoryMin[j]);
        od->auxTrajectoryMean[j] = runningMeanTime(od->auxTrajectoryMean[j], xi[j], dt, elapsedTime);
    }

    if (od->stepcount > 1)
    {
        //local min check - one between each max - simply overwrite tLastMin, xLastMin
        if (od->dxbuffer[1] <= 0.0 && od->dxbuffer[2] > 0.0)
        {
            realtype thisXbuffer[3];
            for (int j = 0; j < 3; ++j)
                thisXbuffer[j] = od->xbuffer[j];
            int ix;
            minOfArray(thisXbuffer, 3, &od->xLastMin, &ix);
            od->tLastMin = od->tbuffer[ix];
        }
    }
}



//Perform and post-integration cleanup and write desired features into the global array F
inline void finalizeFeatures(realtype *ti, realtype xi[], realtype dxi[], realtype auxi[], ObserverData *od, __constant struct ObserverParams *op, __global realtype *F, int i, int nPts)
{
    int ix = 0;
    // F[ix++ * nPts + i] = od->xGlobalMax-od->xGlobalMin;
    F[ix++ * nPts + i] = od->eventcount > 1 ? od->IMI[0] : 0;
    F[ix++ * nPts + i] = od->eventcount > 1 ? od->IMI[1] : 0;
    F[ix++ * nPts + i] = od->eventcount > 1 ? od->IMI[2] : 0;
    // F[ix++ * nPts + i] = od->eventcount > 1 ? od->IMI[0]-od->IMI[1]  : 0;
    F[ix++ * nPts + i] = od->eventcount > 1 ? od->amp[0] : 0;
    F[ix++ * nPts + i] = od->eventcount > 1 ? od->amp[1] : 0;
    F[ix++ * nPts + i] = od->eventcount > 1 ? od->amp[2] : 0;
    // F[ix++ * nPts + i] = od->eventcount > 1 ? od->amp[0]-od->amp[1] : 0;
    // F[ix++ * nPts + i] = od->eventcount > 0 ? od->xMax[0] : xi[op->fVarIx];
    // F[ix++ * nPts + i] = od->eventcount > 0 ? od->xMax[1] : xi[op->fVarIx];
    // F[ix++ * nPts + i] = od->eventcount > 0 ? od->xMax[2] : xi[op->fVarIx];
    // F[ix++ * nPts + i] = od->eventcount > 0 ? od->xMin[0] : xi[op->fVarIx];
    // F[ix++ * nPts + i] = od->eventcount > 0 ? od->xMin[1] : xi[op->fVarIx];
    // F[ix++ * nPts + i] = od->eventcount > 0 ? od->xMin[2] : xi[op->fVarIx];
    F[ix++ * nPts + i] = od->xGlobalMax;
    F[ix++ * nPts + i] = od->xGlobalMin;
    F[ix++ * nPts + i] = od->xTrajectoryMean;
    F[ix++ * nPts + i] = od->dxGlobalMax;
    F[ix++ * nPts + i] = od->dxGlobalMin;
    F[ix++ * nPts + i] = od->eventcount;
    F[ix++ * nPts + i] = od->stepcount;
}

//Perform and post-integration cleanup of observer data to ensure it is ready for continuation if needed
inline void finalizeObserverData(realtype *ti, realtype xi[], realtype dxi[], realtype auxi[], ObserverData *od, __constant struct ObserverParams *op, __constant realtype *tspan)
{
    //shift all time-based observer members left by [tf-t0]
    realtype T = *ti - tspan[0];
    od->t_start -= T;
    od->tLastMax = od->tLastMax - T;
    od->tLastMin = od->tLastMin - T;
    for (int i = 0; i < 3; ++i)
    {
        od->tbuffer[i] = od->tbuffer[i] - T;
    }
}

#endif //USE_OBSERVER_LOCAL_MAX

#endif //OBSERVER_LOCAL_MAX_H
